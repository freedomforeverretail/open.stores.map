<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>High-Performance Canvas Map</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: system-ui, -apple-system, sans-serif;
            touch-action: none; /* Prevent default touch behaviors */
        }
        
        #map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #f0f0f0;
            overflow: hidden;
        }
        
        #map-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* transform-origin is set dynamically in JS */
            will-change: transform; /* Hint to browser for GPU acceleration */
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 12px;
        }
        
        #controls div {
            margin: 5px 0;
        }
        
        .button-group {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        
        button {
            padding: 8px 12px;
            border: none;
            background: #2563eb;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            touch-action: manipulation;
        }
        
        button:active {
            background: #1d4ed8;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <canvas id="map-canvas"></canvas>
        <div id="controls">
            <div><strong>Canvas Map Engine</strong></div>
            <div>Zoom: <span id="zoom-level">12</span></div>
            <div>Tiles Loaded: <span id="tiles-loaded">0</span></div>
            <div>Cache Size: <span id="cache-size">0</span></div>
            <div>FPS: <span id="fps">60</span></div>
            <div class="button-group">
                <button id="zoom-in">+</button>
                <button id="zoom-out">-</button>
                <button id="clear-cache">Clear Cache</button>
            </div>
        </div>
        <div id="loading" class="loading" style="display: none;">Loading tiles...</div>
    </div>

    <script>
        /**
         * HIGH-PERFORMANCE CANVAS MAP ENGINE
         * 
         * Architecture Overview:
         * 1. Single canvas element rendered with tiles
         * 2. During zoom gestures, use CSS transform: scale() for 60fps performance
         * 3. After zoom ends, load new tiles asynchronously
         * 4. In-memory tile cache with LRU eviction
         * 5. Progressive rendering: blurry tiles first, crisp tiles later
         * 6. requestAnimationFrame-based rendering loop to avoid layout thrashing
         */

        class HighPerformanceMapEngine {
            constructor(canvasId, containerId) {
                // DOM elements
                this.canvas = document.getElementById(canvasId);
                this.container = document.getElementById(containerId);
                this.ctx = this.canvas.getContext('2d', { 
                    alpha: false, // Opaque canvas for better performance
                    desynchronized: true // Hint to browser for reduced latency
                });
                
                // Map state
                this.zoom = 12;
                this.center = { lat: 37.7749, lng: -122.4194 }; // San Francisco
                this.tileSize = 256;
                
                // Performance-critical state
                this.isZooming = false;
                this.isPanning = false;
                this.currentScale = 1;
                this.targetZoom = this.zoom;
                
                // Tile management
                this.tileCache = new Map(); // Key: "z/x/y", Value: Image
                this.loadingTiles = new Set(); // Track tiles currently loading
                this.maxCacheSize = 200; // Maximum tiles to keep in memory
                
                // Touch/gesture state
                this.touchStartDistance = 0;
                this.lastTouchTime = 0;
                this.panStart = { x: 0, y: 0 };
                this.panOffset = { x: 0, y: 0 };
                
                // Animation frame tracking
                this.animationFrameId = null;
                this.lastFrameTime = performance.now();
                this.frameCount = 0;
                this.fps = 60;
                
                // Debounce timer for zoom end detection
                this.zoomEndTimer = null;
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.loadInitialTiles();
                this.startRenderLoop();
                console.log('‚úÖ Map engine initialized');
            }
            
            /**
             * STEP 1: Canvas Setup
             * Set canvas to full container size with pixel-perfect rendering
             */
            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.container.getBoundingClientRect();
                
                // Set display size (CSS pixels)
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Set actual size in memory (scaled for retina displays)
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Scale context to match device pixel ratio
                this.ctx.scale(dpr, dpr);
                
                // Set transform origin to center for smooth scaling
                this.canvas.style.transformOrigin = '50% 50%';
                
                console.log('üìê Canvas setup:', {
                    displaySize: `${rect.width}x${rect.height}`,
                    memorySize: `${this.canvas.width}x${this.canvas.height}`,
                    dpr: dpr
                });
            }
            
            /**
             * STEP 2: Event Listeners
             * Handle touch gestures for pinch-zoom and pan
             */
            setupEventListeners() {
                // Touch events for mobile
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                
                // Mouse events for desktop
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                
                // Window resize
                window.addEventListener('resize', this.handleResize.bind(this));
                
                // Button controls
                document.getElementById('zoom-in').addEventListener('click', () => this.zoomTo(this.zoom + 1));
                document.getElementById('zoom-out').addEventListener('click', () => this.zoomTo(this.zoom - 1));
                document.getElementById('clear-cache').addEventListener('click', () => this.clearCache());
            }
            
            /**
             * STEP 3: Touch Gesture Handlers
             * Detect pinch-zoom and apply CSS transform immediately for 60fps
             */
            handleTouchStart(e) {
                e.preventDefault();
                
                if (e.touches.length === 2) {
                    // Pinch zoom start
                    this.isZooming = true;
                    this.touchStartDistance = this.getTouchDistance(e.touches);
                    this.targetZoom = this.zoom;
                    console.log('üëÜ Pinch zoom started');
                } else if (e.touches.length === 1) {
                    // Pan start
                    this.isPanning = true;
                    this.panStart = {
                        x: e.touches[0].clientX - this.panOffset.x,
                        y: e.touches[0].clientY - this.panOffset.y
                    };
                }
                
                this.lastTouchTime = performance.now();
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                if (this.isZooming && e.touches.length === 2) {
                    // Calculate pinch zoom scale
                    const currentDistance = this.getTouchDistance(e.touches);
                    const scale = currentDistance / this.touchStartDistance;
                    
                    // Apply scale immediately via CSS transform (GPU-accelerated, 60fps)
                    this.currentScale = scale;
                    this.canvas.style.transform = `scale(${scale})`;
                    
                    // Calculate target zoom level (clamped between 1-18)
                    const zoomDelta = Math.log2(scale);
                    this.targetZoom = Math.max(1, Math.min(18, this.zoom + zoomDelta));
                    
                    // Update UI
                    this.updateStats();
                    
                } else if (this.isPanning && e.touches.length === 1) {
                    // Pan the map
                    this.panOffset = {
                        x: e.touches[0].clientX - this.panStart.x,
                        y: e.touches[0].clientY - this.panStart.y
                    };
                    this.canvas.style.transform = `translate(${this.panOffset.x}px, ${this.panOffset.y}px) scale(${this.currentScale})`;
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                if (this.isZooming) {
                    // Zoom gesture ended - trigger tile reload after debounce
                    this.isZooming = false;
                    this.debounceZoomEnd();
                    console.log('üéØ Pinch zoom ended, target zoom:', Math.round(this.targetZoom));
                }
                
                if (this.isPanning && e.touches.length === 0) {
                    this.isPanning = false;
                }
            }
            
            /**
             * Mouse wheel handler for desktop zoom
             */
            handleWheel(e) {
                e.preventDefault();
                const delta = -Math.sign(e.deltaY);
                this.zoomTo(this.zoom + delta);
            }
            
            handleMouseDown(e) {
                this.isPanning = true;
                this.panStart = {
                    x: e.clientX - this.panOffset.x,
                    y: e.clientY - this.panOffset.y
                };
            }
            
            handleMouseMove(e) {
                if (this.isPanning) {
                    this.panOffset = {
                        x: e.clientX - this.panStart.x,
                        y: e.clientY - this.panStart.y
                    };
                    this.canvas.style.transform = `translate(${this.panOffset.x}px, ${this.panOffset.y}px) scale(${this.currentScale})`;
                }
            }
            
            handleMouseUp(e) {
                this.isPanning = false;
            }
            
            handleResize() {
                this.setupCanvas();
                this.render();
            }
            
            /**
             * STEP 4: Zoom End Debouncing
             * Wait for user to finish zooming before loading new tiles
             */
            debounceZoomEnd() {
                clearTimeout(this.zoomEndTimer);
                this.zoomEndTimer = setTimeout(() => {
                    this.finalizeZoom();
                }, 150); // Wait 150ms after last zoom gesture
            }
            
            /**
             * STEP 5: Finalize Zoom
             * Called when zoom gesture completes
             * 1. Calculate new zoom level
             * 2. Load tiles for that level
             * 3. Reset CSS transform
             * 4. Redraw canvas with crisp tiles
             */
            async finalizeZoom() {
                const newZoom = Math.round(this.targetZoom);
                
                if (newZoom !== this.zoom) {
                    console.log(`üîÑ Finalizing zoom: ${this.zoom} ‚Üí ${newZoom}`);
                    this.zoom = newZoom;
                    
                    // Show loading indicator
                    document.getElementById('loading').style.display = 'block';
                    
                    // Load tiles for new zoom level
                    await this.loadTilesForCurrentView();
                    
                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';
                    
                    // Preload next zoom level in background
                    this.preloadNextZoomLevel();
                }
                
                // Reset transform to identity
                this.currentScale = 1;
                this.canvas.style.transform = 'translate(0, 0) scale(1)';
                this.panOffset = { x: 0, y: 0 };
                
                // Render with crisp tiles
                this.render();
            }
            
            /**
             * Programmatic zoom (from buttons)
             */
            async zoomTo(newZoom) {
                newZoom = Math.max(1, Math.min(18, Math.round(newZoom)));
                if (newZoom !== this.zoom) {
                    this.zoom = newZoom;
                    this.targetZoom = newZoom;
                    document.getElementById('loading').style.display = 'block';
                    await this.loadTilesForCurrentView();
                    document.getElementById('loading').style.display = 'none';
                    this.render();
                    this.preloadNextZoomLevel();
                }
            }
            
            /**
             * STEP 6: Tile Loading
             * Load tiles asynchronously with progressive rendering
             */
            async loadTilesForCurrentView() {
                const tiles = this.getVisibleTiles();
                const promises = [];
                
                console.log(`üì¶ Loading ${tiles.length} tiles for zoom ${this.zoom}`);
                
                for (const tile of tiles) {
                    const key = `${tile.z}/${tile.x}/${tile.y}`;
                    
                    // Skip if already cached
                    if (this.tileCache.has(key)) {
                        continue;
                    }
                    
                    // Skip if already loading
                    if (this.loadingTiles.has(key)) {
                        continue;
                    }
                    
                    promises.push(this.loadTile(tile.z, tile.x, tile.y));
                }
                
                // Wait for all tiles to load
                await Promise.allSettled(promises);
                
                // Manage cache size
                this.evictOldTiles();
                
                this.updateStats();
            }
            
            /**
             * STEP 7: Individual Tile Loading
             * Load a single tile with fallback logic
             */
            loadTile(z, x, y) {
                return new Promise((resolve, reject) => {
                    const key = `${z}/${x}/${y}`;
                    this.loadingTiles.add(key);
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        // Add to cache
                        this.tileCache.set(key, img);
                        this.loadingTiles.delete(key);
                        
                        // Progressive rendering: draw tile immediately when loaded
                        this.render();
                        
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        this.loadingTiles.delete(key);
                        console.warn(`‚ùå Failed to load tile: ${key}`);
                        
                        // Fallback: try to use lower zoom tile (blurry but better than nothing)
                        this.tryLoadFallbackTile(z, x, y);
                        
                        reject();
                    };
                    
                    // Use OpenStreetMap tiles (free, no API key required)
                    img.src = `https://tile.openstreetmap.org/${z}/${x}/${y}.png`;
                });
            }
            
            /**
             * STEP 8: Fallback Tile Loading
             * If a tile fails, try parent tile (lower zoom) scaled up
             */
            tryLoadFallbackTile(z, x, y) {
                if (z <= 1) return;
                
                // Calculate parent tile coordinates
                const parentZ = z - 1;
                const parentX = Math.floor(x / 2);
                const parentY = Math.floor(y / 2);
                const parentKey = `${parentZ}/${parentX}/${parentY}`;
                
                // If parent exists in cache, use it as fallback
                if (this.tileCache.has(parentKey)) {
                    const key = `${z}/${x}/${y}`;
                    this.tileCache.set(key + '_fallback', this.tileCache.get(parentKey));
                    this.render();
                } else {
                    // Try loading parent tile
                    this.loadTile(parentZ, parentX, parentY);
                }
            }
            
            /**
             * STEP 9: Preloading
             * Preload tiles for next zoom level in background
             */
            preloadNextZoomLevel() {
                const nextZoom = this.zoom + 1;
                if (nextZoom > 18) return;
                
                // Get tiles for next zoom level
                const tiles = this.getVisibleTiles(nextZoom);
                
                console.log(`‚è≥ Preloading ${tiles.length} tiles for zoom ${nextZoom}`);
                
                // Load tiles in background (don't await)
                for (const tile of tiles.slice(0, 20)) { // Limit to 20 tiles for preload
                    const key = `${tile.z}/${tile.x}/${tile.y}`;
                    if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                        this.loadTile(tile.z, tile.x, tile.y).catch(() => {});
                    }
                }
            }
            
            /**
             * STEP 10: Cache Management
             * Evict old tiles using LRU policy
             */
            evictOldTiles() {
                if (this.tileCache.size <= this.maxCacheSize) return;
                
                // Simple LRU: remove tiles from different zoom levels first
                const currentZoomTiles = [];
                const otherZoomTiles = [];
                
                for (const [key, img] of this.tileCache.entries()) {
                    const z = parseInt(key.split('/')[0]);
                    if (z === this.zoom || z === this.zoom + 1 || z === this.zoom - 1) {
                        currentZoomTiles.push(key);
                    } else {
                        otherZoomTiles.push(key);
                    }
                }
                
                // Remove tiles from far zoom levels first
                const toRemove = this.tileCache.size - this.maxCacheSize;
                const keysToRemove = otherZoomTiles.slice(0, toRemove);
                
                keysToRemove.forEach(key => this.tileCache.delete(key));
                
                if (keysToRemove.length > 0) {
                    console.log(`üóëÔ∏è Evicted ${keysToRemove.length} tiles from cache`);
                }
            }
            
            clearCache() {
                this.tileCache.clear();
                this.loadingTiles.clear();
                this.updateStats();
                this.loadTilesForCurrentView().then(() => this.render());
                console.log('üóëÔ∏è Cache cleared');
            }
            
            /**
             * STEP 11: Tile Coordinate Calculation
             * Convert lat/lng to tile coordinates
             */
            getVisibleTiles(zoom = this.zoom) {
                const tiles = [];
                const rect = this.container.getBoundingClientRect();
                
                // Calculate tile range for visible area
                const nwTile = this.latLngToTile(this.center.lat + 0.05, this.center.lng - 0.1, zoom);
                const seTile = this.latLngToTile(this.center.lat - 0.05, this.center.lng + 0.1, zoom);
                
                // Add buffer tiles around visible area
                const minX = Math.max(0, nwTile.x - 1);
                const maxX = Math.min(Math.pow(2, zoom) - 1, seTile.x + 1);
                const minY = Math.max(0, nwTile.y - 1);
                const maxY = Math.min(Math.pow(2, zoom) - 1, seTile.y + 1);
                
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        tiles.push({ z: zoom, x, y });
                    }
                }
                
                return tiles;
            }
            
            latLngToTile(lat, lng, zoom) {
                const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
                const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
                return { x, y };
            }
            
            tileToLatLng(x, y, zoom) {
                const n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
                const lat = (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
                const lng = x / Math.pow(2, zoom) * 360 - 180;
                return { lat, lng };
            }
            
            /**
             * STEP 12: Rendering Loop
             * Use requestAnimationFrame to avoid layout thrashing
             */
            startRenderLoop() {
                const loop = (currentTime) => {
                    // Calculate FPS
                    const deltaTime = currentTime - this.lastFrameTime;
                    this.frameCount++;
                    
                    if (this.frameCount % 30 === 0) {
                        this.fps = Math.round(1000 / deltaTime);
                        this.updateStats();
                    }
                    
                    this.lastFrameTime = currentTime;
                    
                    // Continue loop
                    this.animationFrameId = requestAnimationFrame(loop);
                };
                
                this.animationFrameId = requestAnimationFrame(loop);
            }
            
            /**
             * STEP 13: Canvas Rendering
             * Draw tiles to canvas - called after tiles load, not during zoom
             */
            render() {
                const rect = this.container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, rect.width, rect.height);
                
                // Get visible tiles
                const tiles = this.getVisibleTiles();
                
                // Calculate pixel offset for centering
                const centerTile = this.latLngToTile(this.center.lat, this.center.lng, this.zoom);
                const centerOffset = {
                    x: rect.width / 2,
                    y: rect.height / 2
                };
                
                // Draw tiles
                for (const tile of tiles) {
                    const key = `${tile.z}/${tile.x}/${tile.y}`;
                    const img = this.tileCache.get(key) || this.tileCache.get(key + '_fallback');
                    
                    if (img) {
                        // Calculate tile position relative to center
                        const tileX = (tile.x - centerTile.x) * this.tileSize + centerOffset.x;
                        const tileY = (tile.y - centerTile.y) * this.tileSize + centerOffset.y;
                        
                        // Draw tile
                        this.ctx.drawImage(img, tileX, tileY, this.tileSize, this.tileSize);
                    }
                }
                
                console.log(`üé® Rendered ${tiles.length} tiles`);
            }
            
            /**
             * Initial tile loading
             */
            async loadInitialTiles() {
                document.getElementById('loading').style.display = 'block';
                await this.loadTilesForCurrentView();
                document.getElementById('loading').style.display = 'none';
                this.render();
            }
            
            /**
             * Helper: Calculate distance between two touch points
             */
            getTouchDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            /**
             * Update UI stats
             */
            updateStats() {
                document.getElementById('zoom-level').textContent = this.targetZoom.toFixed(2);
                document.getElementById('tiles-loaded').textContent = this.tileCache.size;
                document.getElementById('cache-size').textContent = this.tileCache.size;
                document.getElementById('fps').textContent = this.fps;
            }
            
            /**
             * Cleanup
             */
            destroy() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }
                this.tileCache.clear();
                this.loadingTiles.clear();
            }
        }
        
        // Initialize map engine
        const mapEngine = new HighPerformanceMapEngine('map-canvas', 'map-container');
        
        // Expose to global scope for debugging
        window.mapEngine = mapEngine;
        
        console.log('üó∫Ô∏è High-performance map engine loaded');
        console.log('üì± Try pinch-zoom on mobile or use buttons to zoom');
        console.log('üéØ Canvas renders at 60fps during zoom gestures');
    </script>
</body>
</html>
